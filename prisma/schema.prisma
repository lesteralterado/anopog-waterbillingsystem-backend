generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url = env("DATABASE_URL")
}

model roles {
  id   BigInt  @id @default(autoincrement())
  name String  @unique
  user users[]
}

model users {
  id             BigInt           @id @default(autoincrement())
  username       String           @unique
  password       String
  role_id        BigInt
  bills          bills[]
  issues         issues[]
  meter_readings meter_readings[]
  notifications  notifications[]
  role           roles            @relation(fields: [role_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  // Keep a relation to the `puroks` table (many-to-many) and also store a simple
  // scalar `purok` value for compatibility with the frontend payload.
  puroks         puroks[]         @relation("puroksTousers")
  purok          String?

  // Additional profile fields requested by the frontend
  meter_number   String?
  full_name      String?
  address        String?
  phone          String?
  email          String?
}

model puroks {
  id    BigInt  @id @default(autoincrement())
  name  String  @unique
  users users[] @relation("puroksTousers")
}

model meter_readings {
  id            BigInt   @id @default(autoincrement())
  user_id       BigInt
  reading_date  DateTime @db.Date
  reading_value Decimal  @db.Decimal
  image_url     String?
  bills         bills[]
  user          users    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model bills {
  id                     BigInt         @id @default(autoincrement())
  user_id                BigInt?
  meter_reading_id       BigInt?
  amount_due             Decimal?       @db.Decimal
  due_date               DateTime?      @db.Date
  is_paid                Boolean?       @default(false)
  // Additional detailed bill fields
  receipt_number         String?
  issue_date             DateTime?
  barangay_name          String?
  homeowner_name         String?
  address                String?
  meter_number           String?
  purok                  String?
  billing_period         String?
  previous_reading       Decimal?       @db.Decimal
  current_reading        Decimal?       @db.Decimal
  consumption            Decimal?       @db.Decimal
  rate_per_cubic_meter   Decimal?       @db.Decimal
  basic_charge           Decimal?       @db.Decimal
  penalties              Decimal?       @db.Decimal
  total_amount           Decimal?       @db.Decimal
  payment_terms          String?
  qr_code                String?
  homeowner_phone        String?
  homeowner_email        String?
  status                 String?        @default("unpaid")
  meter_reading          meter_readings? @relation(fields: [meter_reading_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  user                   users?         @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  payments               payments[]
}

model payments {
  id             BigInt   @id @default(autoincrement())
  bill_id        BigInt
  payment_date   DateTime @db.Date
  payment_method String
  amount_paid    Decimal  @db.Decimal
  fee            Decimal? @db.Decimal @default(0)
  bill           bills    @relation(fields: [bill_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model issues {
  id            BigInt    @id @default(autoincrement())
  user_id       BigInt
  description   String
  reported_date DateTime  @db.Date
  is_resolved   Boolean?  @default(false)
  resolved_date DateTime? @db.Date
  user          users     @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model notifications {
  id                BigInt   @id @default(autoincrement())
  user_id           BigInt
  message           String
  notification_date DateTime @db.Date
  user              users    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}
